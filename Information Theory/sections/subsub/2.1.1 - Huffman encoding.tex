\documentclass{subfiles}
\begin{document}
    Let \(\omega\) be a string to encode, produced by some source \(S\).
    To encode such string, one must perform the following steps:
    \begin{enumerate}
        \item Scan \(\omega\) to get the probabilities of each symbol, 
            unless these are known a priori.

        \item Sort the symbols non-increasingly according to their probabilities.

        \item Build a (binary) tree where the leaves are the source symbols,
            and each node is the sum of the two lowest probabilities.
            Repeat this process until a root is formed.
            
        \item Build the code by traversing the tree from the root to each leaf,
            assigning 0 to left paths and 1 to right paths.
    \end{enumerate}

    \begin{example*}
        Let \(S = \set{1, 2, 3, 4, 5}\) whose probabilities are
            \(\set*{\sfrac{1}{3}, \sfrac{1}{6}, \sfrac{1}{3},
            \sfrac{1}{12}, \sfrac{1}{12}}\), respectively. 
        Applying the steps above yields:
        \begin{description}
            \item [\textbf{Step 1.}] 
                Sorting the symbols according to the probabilities gives the order: \(1, 3, 2, 4, 5\).

            \item [\textbf{Step 2.}] 
                Consider the two least probable symbols, \(d\) and \(e\).
                Their sum defines a new node \(x\) in the tree (the \Ccircle{rpIris} one in the figures).
                The next node \(y\) (the \Ccircle{rpFoam} one) is formed by \(x\) 
                and the third least probable symbol \(b\).
                At this point, node \(z\) (the \Ccircle{rpPine} one) can be obtained by 
                either merging \(a\) and \(c\) or merging \(c\) and \(y\),
                both resulting in an optimal code. 
                
                In this example, \(c\) and \(y\) are merged; the alternative is shown in (\subref{Fig:1.b}).
                Finally, the last two symbols are merged to form the tree (\subref{Fig:1.a}).
                \subfile{../../extra/TikZ/Figure 1 - Example of Huffman encoding}
                
            \item [\textbf{Step 3.}] Traversing the tree produces 
                \(C = \set{0, 10, 110, 1110, 1111}\) for tree (\subref{Fig:1.a}) and
                \(C = \set{00, 01, 10, 110, 111}\) for tree (\subref{Fig:1.b}).
        \end{description}   
    \end{example*}

    From the steps above, it is evident that the slowest part of the encoding
    is the necessity to scan the text twice.
\end{document}
