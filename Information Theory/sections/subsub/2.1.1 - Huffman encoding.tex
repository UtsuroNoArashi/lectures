\documentclass{subfiles}
\begin{document}
    Let \(w\) be a string to encode, produced by some source \(S\).
        To encode such string, one must perform the following steps:
        \begin{enumerate}
            \item Scan \(\omega\) to get the probabilities of each symbol, 
                unless these are known a priori.

            \item Sort the symbols non-increasingly according to their probabilities.

            \item Build a (binary) tree where the leaves are the source symbols,
                and each node is the sum of the two lowest probabilities.
                Repeat this process until a root is formed.
                
            \item Build the code by traversing the tree from the root to each leaf,
                assigning 0 to left paths and 1 to right paths.
        \end{enumerate}

    \begin{example*}
        Let \(S = \set{1, 2, 3, 4, 5}\) whose probabilities are  \(\set*{\sfrac{1}{3}, \sfrac{1}{6}, \sfrac{1}{3},
            \sfrac{1}{12}, \sfrac{1}{12}}\), respectively. Applying the steps above yields:
            \begin{description}
            \item [\textbf{Step 1.}] 
                Sorting the symbols according to the probabilities gives the order: \(1, 3, 2, 4, 5\).

            \item [\textbf{Step 2.}] 
                Consider the two least probable symbols, \(d\) and \(e\).
                Their sum defines a new node \(x\) in the tree (the \Ccircle{rpIris} one in the figures).
                The next node \(y\) (the \Ccircle{rpFoam} one) is formed by \(x\) 
                and the third least probable symbol \(b\).
                At this point, node \(z\) (the \Ccircle{rpPine} one) can be obtained by 
                either merging \(a\) and \(c\) or merging \(c\) and \(y\),
                both resulting in an optimal code. 
                Finally, the last two symbols are merged to form the tree (\subref{Fig:1.a}).
                In this example, \(c\) and \(y\) are merged; the alternative is shown in (\subref{Fig:1.b}).
                \subfile{../../extra/TikZ/Figure 1 - Example of Huffman encoding}

            \vspace{-\baselineskip}
            \item [\textbf{Step 3.}] Traversing the tree produces 
                \(\C* = \set{0, 10, 110, 1110, 1111}\) for tree (\subref{Fig:1.a}) and
                \(\C* = \set{00, 01, 10, 110, 111}\) for tree (\subref{Fig:1.b}).
        \end{description}  
        \vskip -10pt
    \end{example*}

    From the steps above, it is evident that the slowest part of the encoding
    is the necessity to scan the text twice.
\end{document}
