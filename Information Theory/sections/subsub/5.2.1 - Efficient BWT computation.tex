\documentclass{subfiles}
\begin{document}
    Let \(\omega\) be the string for which we wish to compute the BWT, and 
        let \(\tilde{\omega} = \omega\textdollar\), where 
        \(\textdollar \notin \Sigma\). If we compute the BWT of 
        \(\tilde{\omega}\), it suffices to sort the suffixes rather than all cyclic 
        rotations, as would be required for \(\omega\).

    A natural question arises: how are these suffixes computed and sorted? 
        Over the years, many algorithms have been proposed 
        (see \cite{karkkainen2006, ko2005, baier2016}), all of which share a 
        common component: a specialized data structure, the SA. The following 
        section summarizes the algorithm proposed in \cite{karkkainen2006}; 
        for a complete understanding, the original paper is recommended.

    Formally, let \(T = T[1, n]\) be a text, and define \(T_{i}\) as the 
        suffix of \(T\) starting at position \(i\) for all \(i = 1, \ldots, n\). 
        Denote by \(Suf\!f(T)\) the set of all suffixes of \(T\):
        \[
            Suf\!f(T) = \set{T_{i}}[i = 1, \ldots, n].
        \]
        The suffix array, SA, is defined as a sorted array of \(Suf\!f(T)\).

        \begin{remark*}
            Using the SA, the complexity of computing the BWT is reduced to that 
            of the algorithm used to sort the suffixes.
        \end{remark*}

    \paragraph{The DC3 algorithm}
    Let \(S\) be the text for which we wish to compute the suffixes. Our 
        goal is to construct \(SA_{S}\). The first step of the algorithm is to 
        compute the following position sets:
        \[
            B_{k} = \set{i \in [0, n - 1]}[i \bmod 3 = k].
        \]
        Let \(C = B_{1} \cup B_{2}\). For each \(i \in C\), define the triplet 
        \(r_i = [s_{i}, s_{i + 1}, s_{i + 2}]\), padding with \(\textdollar\) 
        if necessary, and define \(R\) as the concatenation of all triplets:
        \[
            R = r_{1} r_{2} \ldots
        \]
        There exists a correspondence between the suffixes of \(R\) and those of \(S\). 
        Next, radix sort the triplets and replace each with its rank to define \(R'\). 
        If all symbols are distinct, the order is determined by the ranks; otherwise, 
        the suffixes of \(R'\) are recursively sorted using the DC3 algorithm to 
        compute \(SA_{R'}\).

    Once the suffixes are computed, for all \(i \in C\) define 
        \(\mathrm{rank}(S_{i})\) as the rank of \(S_{i}\). 
        For all \(i \in B_{0}\), define the pair 
        \((s_{i}, \mathrm{Rank}(S_{i + 1}))\) and sort them as follows: for all 
        \(i, j \in B_{0}\),
        \[
            S_{i} \le S_{j} \iff (s_{i}, \mathrm{Rank}(S_{i + 1})) \le 
            (s_{j}, \mathrm{Rank}(S_{j + 1})),
        \]
        using radix sort on the pairs.

    Finally, merge the two sets of suffixes as follows: for all \(i \in C\) 
        and \(j \in B_{0}\), distinguish two cases:
        \[
        \begin{aligned}
            i \in B_{1}: &\quad S_{i} \le S_{j} \iff 
                (s_{i}, \mathrm{Rank}(S_{i + 1})) \le (s_{j}, \mathrm{Rank}(S_{j + 1})) \\
            i \in B_{2}: &\quad S_{i} \le S_{j} \iff 
                (s_{i}, s_{i + 1}, \mathrm{Rank}(S_{i + 2})) \le 
                (s_{j}, s_{j + 1}, \mathrm{Rank}(S_{j + 2})).
        \end{aligned}
        \]

    \begin{theorem*}
        The complexity of the DC3 algorithm is \(\bigO{n}\).
    \end{theorem*}

    \begin{proof*}
        Aside from the recursive call, all operations can be performed in linear 
        time. The recursion is applied to a string of length \(\sfrac{2n}{3}\), 
        giving the recurrence
        \[
            T(n) = T(\sfrac{2n}{3}) + \bigO{n},
        \]
        whose solution is \(T(n) = \bigO{n}\).
    \end{proof*}

    \begin{example*}
        Let \(S = mathisawesome\). Computing \(B_{k}\) for \(k = 0, 1, 2\), we have
        \[
        \begin{aligned}
            B_{0} &= \set{0, 3, 6, 9, 12}, \\
            B_{1} &= \set{1, 4, 7, 10}, \\
            B_{2} &= \set{2, 5, 8, 11},
        \end{aligned}
        \]
        so that \(C = \set{1, 2, 4, 5, 7, 8, 10, 11}\).

        By considering all \(i \in C\) and computing all \(r_{i}\), we obtain
        \[
            R = [ath][thi][isa][saw][wes][eso][ome][me\textdollar].
        \]
        After radix sorting the triplets, we get
        \[
            R' = (1, 7, 3, 6, 8, 2, 5, 4),
        \]
        from which \(SA_{R'} = (8, 0, 5, 2, 7, 6, 3, 1, 4)\). Note that index 8 
        corresponds to the empty suffix, the lowest in order.

        Before computing \(\mathrm{Rank}(S_{i})\) for all \(i \in C\), reduce 
        \(SA_{R'}\) to \(SA_{R}\) by excluding index 8. Assign ranks to entries 
        in \(SA_{R}\) in order. Then, assign the \(j\)-th rank to the entry of 
        \(R\) at index \(k = SA_{R}[j - 1]\) and trace it back to the corresponding 
        \(S_{i}\). For illustration, see:
        \subfile{../../extra/TikZ/Figure * - Example DC3}

        The remaining steps are left as an exercise to the reader.
    \end{example*}
    \cleardoublepage
\end{document}
