\documentclass{subfiles}
\begin{document} 
    The AC encoding is relatively straightforward, as summarized in the steps below.
    Let \(\omega\) be the text to encode, and assume that the alphabet
        and corresponding probabilities are known. Then:
        \begin{enumerate}
            \item Initialize the range \([0, 1]\).

            \item For each symbol in \(\omega\):
                \begin{enumerate}
                    \item Divide the current range into \(n\) intervals 
                        (\(n\) being the size of the alphabet), 
                        each proportional to the probabilities of the symbols.

                    \item Select as the current subinterval the one corresponding to the symbol
                        being analyzed.
                \end{enumerate}
            \item Output the binary representation\footnotemark of the midpoint of the last subinterval.
        \end{enumerate}
        \footnotetext{We assume the reader is familiar with representing fractional numbers in binary.}

        Algorithmically, this procedure can be implemented via the procedure shown in \emph{Figure \ref{Fig:3}}.
        \clearpage
        \subfile{../../extra/TikZ/Figure 3 - AC encoding snippet}

        \begin{example*}
            Let \(\omega = abac\) and \(S = \set{a, b, c}\)
            with probabilities \(\set*{\sfrac{1}{2}, \sfrac{1}{4}, \sfrac{1}{4}}\).

            By applying the above steps, we obtain:
            \begin{description}
                \item [\textbf{Step 1.}] Initialize the range \([0, 1]\).

                \item [\textbf{Step 2.}] Consider each iteration; 
                    each step is illustrated in \emph{Figure \ref{Fig:4}}.
                    We read ``a'', selecting the range \([0, \sfrac{1}{2}]\).
                    We then update the ranges and repeat the process until the end of the text.
                    \subfile{../../extra/TikZ/Figure 4 - Example of AC encoding.tex}

                \item [\textbf{Step 3.}] Return the midpoint of the last range.
            \end{description}
        \end{example*}

        How many bits are required to represent the encoding? 
        From the code in \emph{Figure \ref{Fig:3}},
            the size of the final range is given by 
            \[
                range_{n} = \prod_{i = 1}^{n}{Prob[S[i]]},
            \]
            from which it follows that the output size is independent of the 
            permutation of the string symbols.
        It can be shown that \(l_{n} + \sfrac{s_{n}}{2}\) bits suffice our needs.
\end{document}
