\documentclass{subfiles}
\begin{document}
    The \gls{ac} encoding is pretty straightforward,
        as summarized in the steps below.
    Let \(\omega\) be the text to encode and let's assume the alphabet,
        alongside the probabities, is know. Then:
        \begin{enumerate}
            \item We start by initializing the range \([0, 1]\).
            \item For each symbol in \(\omega\):
                \begin{enumerate}
                    \item Divide the current range into \(n\) intervals 
                        (n the size of the alphabet), 
                        each proportional to the probabities of the symbols.
                    \item Select as current subinteval the one corresponding to the symbol
                        that is begin analyzed.
                \end{enumerate}
            \item Output the binary representation\footnotemark[1] of the lowerbound of the last subinteval.
        \end{enumerate}
        \begin{example*}
            Let \(\omega = abac\) and let \(S = \Set{a, b, c}\)
            with probabilities \(\Set{\tfrac{1}{2}, \tfrac{1}{4}, \tfrac{1}{4}}\).

            By applying the above steps, we get:
            \begin{description}
                \item [\textbf{Step 1.}] We initialize the range \([0, 1]\).
                \item [\textbf{Step 2.}] Let us consider each iteraction,
                    each step can be observed in \emph{Figure \ref{Fig:3}}.
                    We read ``a'' anddthus, we select the range \([0, \tfrac{1}{2}]\).
                    We proceed to updated the ranges, 
                    and repeat the process until the end of the text.
                    \subfile{../../extra/TikZ/Figure 2 - AC encoding}

                \item [\textbf{Step 3.}] We return the mid value of the last range.
            \end{description}
        \end{example*}
        \footnotetext[1]{We assume the reader knows how fractional numbers are represented in binary.}
        Algorithmically speaking, we simply apply the following code.
        \subfile{../../extra/TikZ/Figure 3 - AC encoding snippet}

        How many bits do we need to represent the encoding? 
        From the code in \emph{Figure \ref{Fig:4}},
            we can deduce that the size of the final range is given by 
            \[
                range_{n} = \prod_{i = 1}^{n}{Prob[S[i]]}
            \]
            from which we can derive that the outpus size is indipendent of the 
            string symbols permutation.
        Then by the above remark, and the following results, 
            we can deduce that we need \(l_{n} + \tfrac{s_{n}}{2}\) bits,
            where \(l_{n} \text{ and } s_{n}\) are, respectively,
            the last two values of \lstinline{low} and \lstinline{high} in the code above.
        \begin{lemma*}
            Let \(x = 0.b_{1}b_{2}\ldots\) be the binary representation of a real number.
            Then, it's truncation to the first \(d\) bits is also a real number,
        \end{lemma*}
        \begin{proof*}
            Let's observe that 
            \[
                x - trunc_{d}(x) = \sum_{i = 1}^{\infty}{b_{d + i} 2^{-(d + i)}}
                \le \sum_{i = 1}^{\infty}{1 * 2^{-(d + i)}} 
                =2^{-d} \sum_{i = 1}^{\infty}{2^{-i}} = 2^{-d}
            \]
            Therefore, 
            \[
                x - trunc_{d}(x) \le 2^{-d} \iff x - d^{-d} \le trunc_{d}(x)
            \]
        \end{proof*}
        \begin{corollary*}
            Given \(x \in [low, high]\) its truncation to the first
            \(\Ceil{\log \tfrac{2}{high - low}}\) falls within the range.
        \end{corollary*}
        \begin{proof*}
            It follows by the above \emph{Lemma} putting 
                \(d = \Ceil{\log \tfrac{2}{high - low}}\).
        \end{proof*}
\end{document}
