\documentclass{subfiles}
\begin{document}
    The \emph{Sardinas-Patterson} algorithm provides a way to check whether a code is UD or not. 
        Conceptually, the algorithm and its underlying theorem are based on the following remark: 
        consider a string that is the concatenation of codewords.
        If we try to construct two distinct factorizations, 
        each word in one of the factorizations is either part of a word in the other factorization,
        or it starts with a prefix that is a suffix of a word in the other factorization.
        Hence, a code is non-UD if a suffix is itself a codeword.

    As stated before, the algorithm is based on a theorem, given below.
    \begin{theorem}\label{Thm:1}
        Given \(C\) a code on an alphabet \(\Sigma\), 
            consider the sets \(S_{0}, S_{1}, \ldots\) such that:
            \begin{itemize}
                \item \(S_{0} = C\) 
                \item \(S_{i} = \set{\omega \in \Sigma^{*}}[
                    \exists \alpha \in S_{0}, \exists \beta \in S_{i - 1} : 
                    \alpha = \beta \omega \lor \beta = \alpha \omega
                ]\)
            \end{itemize}
        Then a necessary and sufficient condition for \(C\) to be a UD code is that
            \(\forall n > 0, S_{0} \cap S_{n} = \varnothing\).
    \end{theorem}
    \clearpage

    \begin{example*}
        Consider the following code: \(C = \set{a, c, ad, abb, bad, deb, bbcde}\).
        Is it UD? Applying Sardinas-Patterson step by step, we get the following:
        \begin{description}
            \item [\textbf{Iteration 1}] Let \(\beta = a\). 
                If we let \(\omega = d\), we have \(\alpha = \beta\omega = ad \in S_{0}\);
                hence, \(\omega = d \in S_{1}\). By the same logic we \(bb \in S_{1}\). 
            
            \item [\textbf{Iteration 2}] Let \(\beta = d\).
                If we let \(\omega = eb\), we get \(\alpha = deb \in S_{0}\);
                thus, \(eb \in S_{2}\). With a similar reasoning we get \(cde \in S_{2}\).

            \item [\textbf{Iteration 3}] Let \(\alpha = c\).
                If we let \(\omega = de\), it derives that \(\beta = cde \in S_{2}\);
                therefore, \(de \in S_{3}\).

            \item [\textbf{Iteration 4}] Let \(\beta = de\).
                If we let \(\omega = b\), we get \(\alpha = deb \in S_{0}\);
                hence, \(b \in S_{4}\).

            \item [\textbf{Iteration 5}] Let \(\beta = b\).
                If we let \(\omega = bcde\), we have \(\alpha = bbcde \in S_{0}\);
                thus, \(bcde \in S_{5}\). By the same logic \(ad \in S_{5}\) 
        \end{description}

        From the above steps (summarised in \emph{Table \ref{Tab:1}}), 
            it follows that the code is not UD since \(S_{0} \cap S_{5} =
            \set{ad} \ne \varnothing\).
        \subfile{../../extra/TikZ/Tab 1 - Example of Sardinas-Patterson}
    \end{example*}
\end{document}
